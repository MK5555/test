"use strict";
//пустой массив создается двумя способами
let arr  = new Array()
let arr2 = []; //обычно используется этот вариант

//в массиве может храниться любой тип данных
let fruits = ["Яблоко", "Апельсин",false, "Слива",true];
console.log(fruits[0],fruits)
//при необходимости можно заменять элементы в массиве
//на другие fruits[1]="other"

//для работы с массивом есть методы
//pop удаляет с конца и возвращает его
//push//вставить в конец
//shift удаляет с начала и возвращает его
//unshift //вставить в начало
console.log(fruits.pop(),fruits)
console.log(fruits.push("new item"),fruits)
console.log(fruits.shift(),fruits)
console.log(fruits.unshift("unshift"),fruits)

/*
массив особый подвид объектов где
в роли ключа числовой ключ
так что ПРИ КОПИРОВАНИИ две
пременные будут ссылаться на один объект

особенность массива в том что для него сщуествует множество
оптимизаций, но если его использовать как обычный объект
то мы не получим никакой выгоды от его использования

Массив следует считать особой структурой,
 позволяющей работать с упорядоченными данными.

так конечно можно делать но не стоит
fruits[99999] = 5;
fruits.age = 25;
Варианты неправильного применения массива:

    Добавление нечислового свойства, например: arr.test = 5.
    Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
    Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.

 */
// методы push/pop выполняются быстро,
// а методы shift/unshift – медленно.
//т.к. последним нужно сдвигать элементы и
//переиндексировать их

//для массивов доступен специальный цикл for of
//ну или если ты извращенец for in т.к. массив это
//тот же объект внутри
//-есть ряд отличий между циклами
//*for in оптимизирован под произвольные объекты
//в отличии от него for of будет быстрее него
//в 10-100 раз
//*for in выводит скрытые свойства для объектов
//что довольно редко нужно
for (let f of fruits){
    console.log(f)
}
//TODO
//length это не длина массива, а максиимальный цифровой индекс +1
//можно также вручную задать длину массива
//при увеличении ничего не произойдет
//а при уменьшении массив обрежется (это необратимый процесс)

//можно создавать многомерные объекты
//
let matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
console.log(matrix)
console.log(matrix[1][1])
//метод возвращает список элементов
//разделенных запятой
console.log(matrix.toString())
console.log(fruits.toString())


// task 1
let styles =["Джаз","Блюз"]
styles.push("Рок")
let center = (styles.length-1)/2
styles[center] = "classic"
console.log(styles.shift())
styles.unshift("Rap")
styles.unshift("Rag")

let arrr = ["a", "b"];

arrr.push(function() {
    console.log( this );
})

arrr[2]();
console.log(arrr)

//task getMaxSubSum
//логика тут такая, что запоминается максимальная сумма
//потом если значение падает ниже нуля начинается новая цепочка
//с суммы 0(т.к. без отрицательной цепочки сумма будет больше),
// если значение не опустилось ниже нуля а потом и превысило строе максимальное значение
//то оно становится новым макс значением (логика обратна отрицательной цепочке)
function getMaxSubSum(arr){
    let maxSum = 0;
    let partialSum = 0;
    for (let item of arr) { // для каждого элемента массива
        partialSum += item; // добавляем значение элемента к partialSum
        maxSum = Math.max(maxSum, partialSum); // запоминаем максимум на данный момент
        if (partialSum < 0) partialSum = 0; // ноль если отрицательное
    }

    return maxSum;
}

console.log(( getMaxSubSum([-1, 2, 3, -9]) )); // 5
console.log(( getMaxSubSum([-1, 2, 3, -9, 11])) ); // 11
console.log(( getMaxSubSum([-2, -1, 1, 2]) )); // 3
console.log(( getMaxSubSum([100, -9, 2, -3,108, 5,])) ); // 100
console.log(( getMaxSubSum([1, 2, 3]) )); // 6
console.log(( getMaxSubSum([-1, -2, -3]) )); // 0







