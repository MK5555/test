сборка мусора основана на принципе достижимости
т.е. достижимые значение это те, которые доступны
или используются
обычно это
*локальные переменные
*переменные и параметры функции в текущей цепочке вызовов
*Глобальные переменные
*некоторые внутренние значения
//эти значения называются корнями
*любое значение считается достижимым если оно доступно по ссылке
или цепочке ссылок из корня
*объект станет недоступным если переменной присвоить null
 тогда сборщик мусора удалить его
* объект делается достижимым только в случае если на него есть ссылки
если он имеет ссылку на другой объект,
но не является корнем и при этом из другого объекта не содержится
ссылк на него то он станет недостижимым
в root есть входящая ссылка из global
          [] - root
           |
            \
             \
child2[]---> [] - child obj
будет удален child2 т.к. нет входящих в него ссылок

также если удалить ссылку входящую в root то объект
будет удален сборщиком не смотря на оставшиеся связи

Основной алгоритм сборки мусора –
«алгоритм пометок» (англ. «mark-and-sweep»).

Согласно этому алгоритму, сборщик мусора регулярно
 выполняет следующие шаги:

    Сборщик мусора «помечает» (запоминает) все корневые объекты.
    Затем он идёт по их ссылкам и помечает все найденные объекты.
    Затем он идёт по ссылкам помеченных объектов
     и помечает объекты, на которые есть ссылка от них.
      Все объекты запоминаются, чтобы в будущем не посещать один и
       тот же объект дважды.
    …И так далее, пока не будут посещены все ссылки
     (достижимые от корней).
    Все непомеченные объекты удаляются.


    Сборка по поколениям (Generational collection) – объекты делятся
    на «новые» и «старые». Многие объекты появляются, выполняют
     свою задачу и быстро умирают, их можно удалять более
      агрессивно. Те, которые живут достаточно долго,
       становятся «старыми» и проверяются реже.
    Инкрементальная сборка (Incremental collection) – если объектов
     много, то обход всех ссылок и пометка достижимых объектов
      может занять значительное время и привести к видимым
       задержкам выполнения скрипта. Поэтому интерпретатор
       пытается организовать сборку мусора поэтапно. Этапы
       выполняются по отдельности один за другим. Это
        требует дополнительного учёта для отслеживания
        изменений между этапами, но зато теперь у нас
        есть много крошечных задержек вместо одной большой.
    Сборка в свободное время (Idle-time collection) – чтобы уменьшить
     возможное влияние на производительность, сборщик мусора старается
     работать только во время простоя процессора.
